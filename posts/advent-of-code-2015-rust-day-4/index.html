<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.5.1"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Learning Rust with Advent of Code - Day 4" /><meta name="author" content="David & Felipe" /><meta property="og:locale" content="en_US" /><meta name="description" content="2015 Day 4: Brute-force search through strings to find those whose MD5 hashes have leading 0s. After solving the problem using Rust&#39;s MD5 crate, we analyze MD5&#39;s algorithm to find possible speedups." /><meta property="og:description" content="2015 Day 4: Brute-force search through strings to find those whose MD5 hashes have leading 0s. After solving the problem using Rust&#39;s MD5 crate, we analyze MD5&#39;s algorithm to find possible speedups." /><link rel="canonical" href="http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/" /><meta property="og:url" content="http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/" /><meta property="og:site_name" content="Hall of Impossible Dreams" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-02-11T12:00:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Learning Rust with Advent of Code - Day 4" /><meta name="twitter:site" content="@thecog19" /><meta name="twitter:creator" content="@David & Felipe" /><meta name="google-site-verification" content="rOMa9oYHtFBq7U58IniOX1gggI6noWpOXoWBk-9hItk" /> <script type="application/ld+json"> {"description":"2015 Day 4: Brute-force search through strings to find those whose MD5 hashes have leading 0s. After solving the problem using Rust&#39;s MD5 crate, we analyze MD5&#39;s algorithm to find possible speedups.","@type":"BlogPosting","headline":"Learning Rust with Advent of Code - Day 4","url":"http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/","dateModified":"2021-02-11T12:00:00-05:00","datePublished":"2021-02-11T12:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/"},"author":{"@type":"Person","name":"David & Felipe"},"@context":"https://schema.org"}</script><title>Learning Rust with Advent of Code - Day 4 | Hall of Impossible Dreams</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script async src="https://www.googletagmanager.com/gtag/js?id=G-QGYEJ40C64"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-QGYEJ40C64'); </script> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">Hall of Impossible Dreams</a></div><div class="site-subtitle font-italic">A repository of code, fiction, nonfiction, and poetry.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/hallofdreams" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/thecog19" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['felipe.suero19','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Learning Rust with Advent of Code - Day 4</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Learning Rust with Advent of Code - Day 4</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Feb 11, 2021, 12:00 PM -0500" > Feb 11, 2021 <i class="unloaded">2021-02-11T12:00:00-05:00</i> </span> <span class="author"> by David & Felipe </span></div></div><div class="post-content"><h3>Series Navigation</h3><li><a href="/posts/advent-of-code-2015-rust-day-1/">Learning Rust with Advent of Code - Day 1</a><li><a href="/posts/advent-of-code-2015-rust-day-2/">Learning Rust with Advent of Code - Day 2</a><li><a href="/posts/advent-of-code-2015-rust-day-3/">Learning Rust with Advent of Code - Day 3</a><li><b>Learning Rust with Advent of Code - Day 4</b><li><a href="/posts/advent-of-code-2015-rust-day-5/">Learning Rust with Advent of Code - Day 5</a><li><a href="/posts/advent-of-code-2015-rust-day-6/">Learning Rust with Advent of Code - Day 6</a></div><hr><div class="post-content"><div style="display:none;">2015 Day 4: Brute-force search through strings to find those whose MD5 hashes have leading 0s. After solving the problem using Rust's MD5 crate, we analyze MD5's algorithm to find possible speedups.</div><h1 id="day-4"><a href="https://www.adventofcode.com/2015/day/4">Day 4</a></h1><p>The problem: you’re given a string, to which you’ll append integers <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, …</p><p><strong>Part 1</strong>: Find the lowest number which, when appended to the string, produces an MD5 hash with five leading zeroes.</p><p><strong>Part 2</strong>: Find the lowest number which, when appended to the string, produces an MD5 hash with six leading zeroes.</p><h1 id="david">David</h1><p>This one is probably going to be my largest speedup of 2015’s Advent of Code: Mathematica’s built-in MD5 function was so slow that I didn’t use it for future MD5 problems, just this one. It took 120.07 seconds to get part 2 with the built-in function in Mathematica: I’d like to see a thousand-fold speedup, at least.</p><h2 id="attempt-00">Attempt 0.0</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
		<span class="nf">.chain</span><span class="p">(</span><span class="n">input_raw</span><span class="p">)</span>
		<span class="nf">.chain</span><span class="p">(</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span>
		<span class="nf">.finalize</span><span class="p">();</span>
	
	<span class="nd">println!</span><span class="p">(</span><span class="s">"First MD5: {}"</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre>    Updating crates.io index
  Downloaded typenum v1.12.0
  Downloaded generic-array v0.9.0
  Downloaded digest v0.7.6
  Downloaded byte-tools v0.2.0
  Downloaded block-buffer v0.3.3
  Downloaded arrayref v0.3.6
  Downloaded md-5 v0.7.0
  Downloaded 7 crates (91.9 KB) in 0.56s
   Compiling typenum v1.12.0
   Compiling byte-tools v0.2.0
   Compiling arrayref v0.3.6
   Compiling block-buffer v0.3.3
   Compiling generic-array v0.9.0
   Compiling digest v0.7.6
   Compiling md-5 v0.7.0
   Compiling day_4 v0.1.0 (/home/david/Programming/Advent of Code/2015/Rust/day_4)
error[E0599]: no method named `chain` found for struct `Md5` in the current scope
   |
10 |         .chain(input_raw)
   |          ^^^^^ method not found in `Md5`
   | 
  ::: /home/david/.cargo/registry/src/github.com-1ecc6299db9ec823/md-5-0.7.0/src/lib.rs:29:1
   |
29 | pub struct Md5 {
   | -------------- doesn't satisfy `Md5: Iterator`
   |
   = note: the method `chain` exists but the following trait bounds were not satisfied:
           `Md5: Iterator`
           which is required by `&amp;mut Md5: Iterator`
</pre></table></code></div></div><p>First issue: there are actually two packages which implement <code class="language-plaintext highlighter-rouge">MD5</code> in Rust: <code class="language-plaintext highlighter-rouge">md5</code> and <code class="language-plaintext highlighter-rouge">md-5</code>. The latter is part of a wider network of <a href="https://github.com/RustCrypto/hashes">cryptographic Rust functions and crates</a>, so I think that’s the one I want, but the confusion isn’t great.</p><p>More concerningly, though, is the second issue: the syntax (which I copied straight from the documentation) does not work. Since the documentation lists the <code class="language-plaintext highlighter-rouge">digest()</code> function as well, perhaps we can get away with concatenating the string inside the digest and doing it that way.</p><h2 id="attempt-01">Attempt 0.1</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">(</span><span class="n">input_raw</span> <span class="o">+</span> <span class="n">i</span><span class="nf">.to_string</span><span class="p">());</span>

	<span class="nd">println!</span><span class="p">(</span><span class="s">"First MD5: {:x}"</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>error[E0308]: mismatched types

let mut hash = Md5::digest(input_raw + i.to_string());
                                       ^^^^^^^^^^^^^
                                       |
                                       expected `&amp;str`, found struct `String`
                                       help: consider borrowing here: `&amp;i.to_string()`

error[E0308]: mismatched types

let mut hash = Md5::digest(input_raw + i.to_string());
                           ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&amp;[u8]`, found struct `String`
</pre></table></code></div></div><p>This tells me that <code class="language-plaintext highlighter-rouge">digest</code> expects a vector of 8-bit numbers, which shouldn’t be difficult. It also tells me that <code class="language-plaintext highlighter-rouge">+</code> works as a concatenation operator if I pass in a reference; good to know for later. According to the documentation, <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes"><code class="language-plaintext highlighter-rouge">as_bytes</code></a> returns a vector of bytes from a <code class="language-plaintext highlighter-rouge">String</code>, and I can preallocate that vector of bytes.</p><h2 id="attempt-02">Attempt 0.2</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>

	<span class="nd">println!</span><span class="p">(</span><span class="s">"First MD5: {:x}"</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Finished release [optimized] target(s) in 0.37s
 Running `target/release/day_4`
First MD5: 71a54df5b9348fb5e473970ba9e36453
</pre></table></code></div></div><p>Okay! That went better than expected. Time to try a loop.</p><h2 id="attempt-03">Attempt 0.3</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
	<span class="nd">println!</span><span class="p">(</span><span class="s">"MD5 {}: {:x}"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>error[E0382]: use of moved value: `input_raw`

let input_raw: String = fs::read_to_string(file).unwrap();
    --------- move occurs because `input_raw` has type `String`, which does not implement the `Copy` trait
...
let mut hash = Md5::digest((input_raw + &amp;i.to_string()).as_bytes());
                            ^^^^^^^^^ value moved here, in previous iteration of loop
</pre></table></code></div></div><p>This is what I was worried about; the concatenation operator works, but it borrows the original string. Fortunately, even though <code class="language-plaintext highlighter-rouge">String</code> does not implement the <code class="language-plaintext highlighter-rouge">Copy</code> trait, it does implement the <code class="language-plaintext highlighter-rouge">Clone</code> trait (I’m unsure of the difference), so I can just use that.</p><h2 id="attempt-04">Attempt 0.4</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
		<span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
		<span class="nd">println!</span><span class="p">(</span><span class="s">"MD5 {}: {:x}"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>Compiling day_4 v0.1.0 (/home/david/Programming/Advent of Code/2015/Rust/day_4)
 Finished release [optimized] target(s) in 0.38s
  Running `target/release/day_4`
MD5 1: 71a54df5b9348fb5e473970ba9e36453
MD5 2: bb9eb4a19114eb25c0fb75f45688c562
MD5 3: 997acccc1d4f625dc6e8318725dce7e3
MD5 4: c1a1c0bd9881ac01e00d24c39b8a37b9
MD5 5: 96c90020ef3e3ae00d6dfae8031aeb19
MD5 6: 6bfd2b83794f3b22d35aa5bd17e5e7f0
MD5 7: 3a45dceb179828a206150e5b9f88bc74
MD5 8: 7cb64e4f857d76f49e3d55706c122d96
MD5 9: a8290c156e6003f803d530787cddf969
</pre></table></code></div></div><p>The code works and I have my MD5 hashes. Let me try moving the print statement after the while loop, so it only prints once.</p><h2 id="attempt-10">Attempt 1.0</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
		<span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
		<span class="nd">println!</span><span class="p">(</span><span class="s">"MD5 {}: {:x}"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>error[E0425]: cannot find value `hash` in this scope

println!("MD5 10: {:x}",hash);
                        ^^^^ not found in this scope
</pre></table></code></div></div><p>This is fascinating, and this is one of the many differences between a high-level and low-level language. Rust apparently assigns a <code class="language-plaintext highlighter-rouge">scope</code> to every variable, and if a variable is created inside a <code class="language-plaintext highlighter-rouge">while</code> loop, it can’t be referenced outside that <code class="language-plaintext highlighter-rouge">while</code> loop. If I did something similar in Mathematica, I could use a <code class="language-plaintext highlighter-rouge">Module[]</code> to define a local variable, but here I suppose that scopes are everywhere. I could fix this by defining <code class="language-plaintext highlighter-rouge">hash</code> before the loop, but that was only ever a debug statement anyway, so I may as well crack on with the problem.</p><h2 id="attempt-11">Attempt 1.1</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">part2</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100_000</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">let</span> <span class="k">mut</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
		
		<span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">hash</span><span class="nf">.pop</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">continue</span><span class="p">};</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="n">part1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="n">part1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="nd">println!</span><span class="p">(</span><span class="s">"Part 1: {:x}"</span><span class="p">,</span><span class="n">part1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>error[E0599]: no method named `pop` found for struct `generic_array::GenericArray&lt;u8, typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UTerm, typenum::bit::B1&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;&gt;` in the current scope

if hash.pop() != 0 {
       ^^^ method not found in `generic_array::GenericArray&lt;u8, typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UInt&lt;typenum::uint::UTerm, typenum::bit::B1&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;, typenum::bit::B0&gt;&gt;`
</pre></table></code></div></div><p>I tried to be clever and use the built-in <code class="language-plaintext highlighter-rouge">pop()</code> method for <code class="language-plaintext highlighter-rouge">Vec</code>, not realizing that what <code class="language-plaintext highlighter-rouge">digest()</code> returns is not a <code class="language-plaintext highlighter-rouge">Vec</code> but in fact a <code class="language-plaintext highlighter-rouge">GenericArray</code>, which is a fixed-length array. So much for cleverness, I suppose.</p><h2 id="attempt-12">Attempt 1.2</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">part2</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="nv">'outer</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100_000</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
		
		<span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">5</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">hash</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">continue</span> <span class="nv">'outer</span><span class="p">};</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="n">part1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="n">part1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="nd">println!</span><span class="p">(</span><span class="s">"Part 1: {:x}"</span><span class="p">,</span><span class="n">part1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>error: labeled expression must be followed by `:`

      'outer while i &lt; 100_000 {
      ^------ help: add `:` after the label
      |
 _____the label
|
|         i += 1;
|         let hash = Md5::digest((input_raw.clone() + &amp;i.to_string()).as_bytes());
|         
|
|         }
|     };
|_____^
|
   = note: labels are used before loops and blocks, allowing e.g., `break 'label` to them
</pre></table></code></div></div><p>I’m a bit disappointed that I didn’t get a numbered error message for this one; I’m only at 13 unique error codes out of the <a href="https://doc.rust-lang.org/error-index.html">422 possible compiler error codes emitted in this version of Rust</a>, and I’ll really need to pick up the pace if I want a decent score by the end of the month. I realized while fixing the last issue that my <code class="language-plaintext highlighter-rouge">continue</code> only exited the innermost loop, and so I tried to label the outermost loop to specify the which loop should be jumped to.</p><p>I’ll fix that, of course, but now I see another problem. The digest is in <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code>, which means that I’m checking pairs of hexadecimal digits rather than individual hexadecimal digits. While this works fine for part 2 - I could just check three pairs - I’ll have to modify it a little bit. Also, vectors in Rust are 0-indexed, meaning that I have to change that bit too. But I’m close.</p><h2 id="final-version">Final Version</h2><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::{</span><span class="n">Instant</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
	
	<span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="s">"../Inputs/Day4Input.txt"</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">input_raw</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
	<span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">input_raw</span><span class="nf">.len</span><span class="p">();</span>
	<span class="n">input_raw</span><span class="nf">.truncate</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Normally I filter out the trailing newline, but here it's too annoying.</span>
	
	<span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">part1</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">let</span> <span class="k">mut</span> <span class="n">part2</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="nv">'outer</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_raw</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
		
		<span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="mi">1</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">hash</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">continue</span> <span class="nv">'outer</span><span class="p">};</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="n">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">part1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">part1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;}</span>
			<span class="k">if</span> <span class="n">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="n">part2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="k">break</span><span class="p">;}</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.elapsed</span><span class="p">()</span><span class="nf">.as_micros</span><span class="p">();</span>
	
	<span class="nd">println!</span><span class="p">(</span><span class="s">"Part 1: {}"</span><span class="p">,</span><span class="n">part1</span><span class="p">);</span>
	<span class="nd">println!</span><span class="p">(</span><span class="s">"Part 2: {}"</span><span class="p">,</span><span class="n">part2</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Time: {} μs"</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Part 1: 254575
Part 2: 1038736
Time: 199189 μs
</pre></table></code></div></div><p>I skipped to the end here, because my remaining troubles were with realizing that <code class="language-plaintext highlighter-rouge">read_to_string()</code> includes a trailing newline for some reason, and getting a program which ran but returned the wrong answer. So, stars 7 and 8 acquired! The program runs in 199 ms, for a speedup of 600x over my Mathematica script, and unlike the previous days where the difference was between milliseconds and microseconds, this time the program went from “takes a noticeable and annoying amount of time to run” to “does not take any appreciable time to run”.</p><p>I was hoping for a thousand-fold speedup, but it’s hard to see how to improve upon this much; the only easy thing I thought of is to precompute the <code class="language-plaintext highlighter-rouge">input_raw.clone()</code> into its <code class="language-plaintext highlighter-rouge">as_bytes()</code> form, but trying that, the runtime only went down to 185 ms. To get much further, I think I’d need a deeper understanding of Md5 and the way Rust allocates vectors; maybe create a new fixed-length vector every power of 10, and change only the specific elements that need changing whenever <code class="language-plaintext highlighter-rouge">i</code> increases? I don’t even know if that would work, let alone if that’d be faster.</p><p>So, beating ~185 ns per Md5 hash is going to be difficult for these problems, but all in all, I’m happy with that.</p><h1 id="felipe">Felipe</h1><h2 id="understanding-md5">Understanding MD5</h2><p>I promised we’d do things in parallel today, and we shall, but first, lets try to solve the base problem. Essentially what we’re being asked to do is compute a large amount of static content that is not depenendent on previous content. Specifically we’re looking at md5 hashes, which is a one way transformation applied to a specific string. We don’t need to understand the algorithm fully since we have a crate to implement it for us… but we probably should at least look at it. Because sometimes we can find shortcuts for our specific use-case.</p><p>Like all challenging problems, we start by looking for an explanation of what the heck we’re dealing with. Usually this means wikipedia. A quick search takes us <a href="https://en.wikipedia.org/wiki/MD5">here</a>. We should read carefully in case there’s a footnote pointing to “by the way there’s a super known vulnerability that happens to answer your problem”, but alas that’s not the case. Some neat info and what I can only describe as a bunch of mathematical mumbo-jumbo. I’m sure if I were Dave this would make perfect sense, but I don’t have the same math background.</p><p>What I do know however, is that generally you can <em>understand</em> what mathmaticans are trying to say if you just realize that more often than not they’re tying to be hyper-precise. This applies doubly to cryptographers, who are really just mathmaticians in diguise. This might not make any sense right now:</p><p>&lt;img=https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/MD5_algorithm.svg/450px-MD5_algorithm.svg.png&gt;&lt;/img&gt;</p><p>But we can probably reach a point where it makes enough sense to us. Lets read the bits around it first.</p><p><code class="language-plaintext highlighter-rouge">MD5 processes a variable-length message into a fixed-length output of 128 bits.</code></p><p>Ok, so no matter how long our message is, at the end we’re going to have 128 bits. Having played around with the md5 crate and putting random inputs into it, we can see that’s true. Our output is always the same length. Immediately we might think “since we only care about the first x characters being 0’s, can we just not care about the other 122 bits?”. An instinct we’ll soon see is misguided, since the hash is generated using the full text, but a good instinct to have. We should <em>always</em> be thinking about how to make the problem shorter, care about fewer things.</p><p>Technically, we could probably stop thinking about the particulars of md5 after figuring out we can’t really skip looking at the whole text… but maybe for our use-case we could implement a simpler version of md5? Lets read further and see what the algorithm is actually doing.</p><p><code class="language-plaintext highlighter-rouge">The input message is broken up into chunks of 512-bit blocks (sixteen 32-bit words); the message is padded so that its length is divisible by 512.</code></p><p>Ok sure, so we take the message and cut it up into blocks, and then cut up those blocks into words. If the message is not long enough, we make it longer. How?</p><p><code class="language-plaintext highlighter-rouge">The padding works as follows: first a single bit, 1, is appended to the end of the message. This is followed by as many zeros as are required to bring the length of the message up to 64 bits fewer than a multiple of 512. The remaining bits are filled up with 64 bits representing the length of the original message, modulo 2^64.</code></p><p>A one, followed by some zeroes, followed by the last 64 bits of the message, which are <code class="language-plaintext highlighter-rouge">len(input) % 2^64</code>. This means that if the message length changes, the final output will change, letting us know we <em>really</em> can’t take a shortcut like only caring about the first x characters of our input.</p><p>And now we get to the mathy, incomprehensible bit. I’m going to try to make it vaguely understandable. There’s a rule about crypto though, if you’re ever tempted to implement your own cryptographic function… don’t. Unless you’re only using it for AoC or something, because fundamentally, crypto is very very hard, and there’s a lot of hyper-specialized brilliant minds out there who only work on that. Write your own crypto for fun, never for production.</p><p>Ok, now the math.</p><p><code class="language-plaintext highlighter-rouge">The main MD5 algorithm operates on a 128-bit state, divided into four 32-bit words, denoted A, B, C, and D.</code></p><p>Ok this isn’t too bad. We have a “state” which implies a mutable variable or collection of variables. In this case its a collection of variables called A, B, C and D.</p><p><code class="language-plaintext highlighter-rouge">These are initialized to certain fixed constants</code></p><p>They always start as the same values. Which is good, because it ensures that for the same input we’ll always have the same output. Intuitively that makes sense. No randomness here.</p><p><code class="language-plaintext highlighter-rouge">The main algorithm then uses each 512-bit message block in turn to modify the state</code></p><p>Aha! So we take out 512 sized message blocks, and use them to modify these variables, A, B, C, D.</p><p><code class="language-plaintext highlighter-rouge">The processing of a message block consists of four similar stages, termed rounds; each round is composed of 16 similar operations based on a non-linear function F, modular addition, and left rotation.</code></p><p>Ok so we take these four variables, and for each variable we do one of three opterations, either a non-linear function F, a modular addition, or a left rotation. So we do 64 of these operations and out comes a hash. These are modified by our word blocks that we generated in the first step, which is what makes each hash different.</p><p>Without going any further, two things are clear</p><ol><li><p>We have to coumpute the whole thing every time. Since we operate on each word block as an input to modify state. We cannot predict what some of the characters are going to be based on the input without computing the whole thing. No shortcuts there.</p><li><p>Our times is probably best spent not reinventing the wheel. Its unlikely that as a crypto amateur I’m going to somehow discover a better way to do MD5 hashes.</p></ol><p>Still, that was by no means a waste of time. We learned a little about hashing algorithms, and about reading dense mathy looking things. We can now confidently use the md5 crate without it being a black box.</p><p><em><strong>EDIT:</strong> Felipe missed a trick here. Stopping at iteration 61 would allow us to shortcut through three unnecessary steps, for a speedup of ~4.5%. The key is in the <a href="https://en.wikipedia.org/wiki/MD5#Pseudocode">Wikipedia pseudocode</a> for MD5 (specifically, the very end of the <code class="language-plaintext highlighter-rouge">for i from 0 to 63</code> loop), and the fact that for this specific problem we only need the first quarter of the 512 bit chunk that’s being calculated. The shortcut implementation is left to the reader. -David</em></p><h2 id="first-attempt">First Attempt</h2><p>So lets get back to code. Lets write the base, simple implementation of what our algorithm might look like. As a reminder, we’re trying to compute the smallest value which appended to our input, results in an md5 hash starting with 5 zeroes for part 1, and 6 zeroes for part 2.</p><p>A very basic approach looks like this</p><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::{</span><span class="n">Instant</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nb">str</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span>
       
        <span class="k">let</span> <span class="n">file</span> <span class="o">=</span><span class="s">"../input.txt"</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input_string</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        <span class="n">input_string</span><span class="nf">.truncate</span><span class="p">(</span><span class="n">input_string</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> 
        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p1_done</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">res_arr_p1</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">00</span><span class="p">;</span> <span class="mi">2</span><span class="p">];</span> 
        <span class="k">let</span> <span class="n">res_arr_p2</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">00</span><span class="p">;</span> <span class="mi">3</span><span class="p">];</span> 
        <span class="k">while</span> <span class="k">true</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_string</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
            <span class="c1">// println!("MD5 {}: {:x}",i,hash);</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
           
            <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">hash</span><span class="nf">.as_slice</span><span class="p">();</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">p1_done</span><span class="p">{</span>
                <span class="k">if</span>  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">res_arr_p1</span><span class="p">{</span>
                    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">{</span>
                        <span class="n">p1_done</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"P1 {}: {:x}"</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">res_arr_p2</span><span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"P2 {}: {:x}"</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.elapsed</span><span class="p">()</span><span class="nf">.as_micros</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> execution time in microseconds {}"</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The only tricky bit is the <code class="language-plaintext highlighter-rouge">res_array</code> bit. It turns out that the hash function in the crate produces a bit array of base 16 value numbers (whcih makes some sense now that we understand md5 better!). We want to match the binary representation of those, so instead of doing a conversion we make an array of similar base 16 values. Dave’s take is more elegant, but mine makes more sense to me.</p><p>We run this code, and what do we get? Two stars and a execution time of 568560 microseconds,or about half a second. Not bad for computing over a million md5 hashes, but we can <em>absolutely</em> do better.</p><p>When I was prepping for this blog series, I knew this problem would either take the form of reinventing MD5, or parallelism, because hash calculations can be done without knowing the result of the previous operation, and because we’re working in a serially increasing problem space. Now that we know we’re not out to reinvent md5, we can try to make things work in parallel.</p><h2 id="parallelization">Parallelization</h2><p>What does that even mean? What exactly are we doing and how do we know to do it here?</p><p>For starters, parallelization takes advantage of the fact that modern computers can run serveral CPU threads. Each thread can be thought of as its own computing stream, not blocking other threads from doing their own thing. If a program is a factory, with a shared floor, then the threads are different converyor belts.</p><p>We want to use parallel processes when a few conditions are met:</p><ol><li><p>The results of each thread can be independent of each other. For example, if we were calculating the md5 hash of the previous md5 hash, this would not work at all, since we’d need to wait on the results of one computation before moving on to the next.</p><li><p>The process is cpu bound. Ram is still a global resource, if you’re using all the ram in your machine up with one thread, adding more will only complicate things more.</p><li><p>The process is long running. There is a cost to spawning a thread, you would not want to do just one computation and then terminate the thread.</p></ol><p>This will become more clear as we examine some code. This is also the first time we’re really breaking our code up into discrete functions. Its good practice to do so, as it mantains logical separation, and we’ll be doing it more aggresively from here on out.</p><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::{</span><span class="n">Instant</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fs</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">md5</span><span class="p">::{</span><span class="n">Md5</span><span class="p">,</span> <span class="n">Digest</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nb">str</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">thread_spawner</span><span class="p">(</span><span class="n">input_string</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">p1_done</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">calc_hashes</span><span class="p">(</span><span class="n">input_string</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">p1_done</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">t</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">calc_hashes</span><span class="p">(</span><span class="n">input_string</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="n">p1_done</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res_arr_p1</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">00</span><span class="p">;</span> <span class="mi">2</span><span class="p">];</span> 
    <span class="k">let</span> <span class="n">res_arr_p2</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">00</span><span class="p">;</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result1</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result2</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">start</span><span class="o">..</span><span class="n">end</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nn">Md5</span><span class="p">::</span><span class="nf">digest</span><span class="p">((</span><span class="n">input_string</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">hash</span><span class="nf">.as_slice</span><span class="p">();</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">p1_done</span><span class="p">{</span>
            <span class="k">if</span>  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">res_arr_p1</span><span class="p">{</span>
                <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">{</span>
                        <span class="n">result1</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
                            <span class="n">result2</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                            <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span> 
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span>
       
        <span class="k">let</span> <span class="n">file</span> <span class="o">=</span><span class="s">"../input.txt"</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input_string</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
        <span class="n">input_string</span><span class="nf">.truncate</span><span class="p">(</span><span class="n">input_string</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> 
        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p1_done</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">100_000</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">answer1</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">answer2</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="nv">'outer</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span> 
			<span class="c1">// println!("Current offset: {}; current answer: {}",offset, answer);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">thread_spawner</span><span class="p">(</span><span class="n">input_string</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">i</span><span class="o">*</span><span class="n">chunk_size</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">chunk_size</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">p1_done</span><span class="p">);</span>
                <span class="n">children</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.join</span><span class="p">();</span>
                <span class="k">match</span> <span class="n">curr</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="c1">//https://doc.rust-lang.org/reference/expressions/tuple-expr.html</span>
                		<span class="k">match</span> <span class="n">options</span><span class="na">.0</span> <span class="p">{</span>
                	        <span class="nf">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">=&gt;</span>  <span class="p">{</span><span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">answer1</span> <span class="p">||</span> <span class="n">answer1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="n">answer1</span> <span class="o">=</span> <span class="n">result</span><span class="p">;}}</span>
                			<span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">continue</span>
                        <span class="p">};</span>
                        <span class="k">match</span> <span class="n">options</span><span class="na">.1</span> <span class="p">{</span>
                	        <span class="nf">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">=&gt;</span>  <span class="p">{</span><span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">answer2</span> <span class="p">||</span> <span class="n">answer2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span><span class="n">answer2</span> <span class="o">=</span> <span class="n">result</span><span class="p">;}}</span>
                			<span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">continue</span>
                        <span class="p">};</span>
                    <span class="p">}</span>
                	<span class="nf">Err</span><span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="n">answer2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		        <span class="n">offset</span> <span class="o">+=</span> <span class="n">i</span><span class="o">*</span><span class="n">chunk_size</span><span class="p">;</span>
		        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            	<span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.elapsed</span><span class="p">()</span><span class="nf">.as_micros</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Part 1: {}"</span><span class="p">,</span><span class="n">answer1</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Part 2: {}"</span><span class="p">,</span><span class="n">answer2</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> execution time in microseconds {}"</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What the heck is going on here?</p><p>Lets look at the functions, as we’re probably better served understanding what each thread is doing first, and then how we control it:</p><p><code class="language-plaintext highlighter-rouge">thread_spawner</code>: This functions spawns threads, but what’s with its return value? What’s a <code class="language-plaintext highlighter-rouge">JoinHandle</code>? While I’m going to explain things, as usual we are best served by the documentation. In this case the <a href="https://doc.rust-lang.org/book/ch16-01-threads.html">rust book</a> does an <em>excellent</em> job of explaining things. To whit, a thread is an async process. That means its going to go run off, do its own thing, and one day come back with a result. That could be in a microsecond, it could be in a year. Neither we nor the compiler have any way of knowing. That’s why we have JoinHandles. JoinHandles are, essentially, blockers. They say “this is a process that will one day return a value”. When we call “join” on a JoinHandler, we’re saying. “wait here, and give me back whatever result comes out.”</p><p>Its actually vitally important that we have blockers like that when we parallelize. Otherwise we can often wind up spawning infinite threads (as our thread spawner doesn’t wait for any to finish and just keeps going), slowing down all our threads, or worse, main finishes without waiting for the threads to finish, never giving us our results, and causing the execution to end. Always think about where you’re going to block to wait for existing threads to finish when parallelizing.</p><p><code class="language-plaintext highlighter-rouge">calc_hashes</code>: This is just our old hash calculation, cut out of main, and tweaked to take some variables so it iterates only over values we care about. It also returns a tuple with answers for p1 and p2, contained in a options block. We’ve covered option blocks before (or at least Dave has), but in essence, an option block can either be None or a Result. Usually in our case it’ll be None, unless we’ve found an answer within the specific value range we’ve given this function.</p><p>The key thing to notice about <code class="language-plaintext highlighter-rouge">calc_hashes</code> is that it iterates over a range of values, meaning we can spawn a thread for something like 1001-2000, without needing to compute the previous values. As mentioned, this is a prerequisite for proper threading. It also needs to be able to return both possible answers, in case we set an absurd range like 10,000,000 and one single thread finds both answers.</p><p><code class="language-plaintext highlighter-rouge">main</code>: Now that we understand the other functions, we can look at what <code class="language-plaintext highlighter-rouge">main </code>is doing. Nothing about it should be that alien.</p><p>First we run the <code class="language-plaintext highlighter-rouge">spawn_thread</code> function some arbitrary number of times equal to the number of threads we want. This will be determined by your cpu (which will tell you how many threads you can run). You should be trying to match that number, as any higher numbers will result in thread swapping and loss of preformance. It will probably be a base 2 number, but google is your friend here.</p><p>We take those threads and each is responsible for a chunk of numbers, in this case 100,000, after which the thread will return an option with either an answer for p1 or None, and and answer for p2 or None. Theoretically a given thread could find both answers. We make sure to call .join() on each thread so we block for them to be done, then we process all 16 of the threads and look at their answers. We could theoretically do some kind of optimization surrounding the order of calling joins, but that is beyond the scope of our first effort at parallelization.</p><p>The offset is where we start from after a given set of threads have completed. Think of it like a moving index.</p><p>This may <em>seem</em> like a lot, but its very possible to do, especially tackling one problem at the time. I suggest trying to get a single thread to spawn, and going from there. You will run into type errors, and all kinds of fun, but all that is part of the system guaranteeing you thread safety.</p><p>Now, with this code under our belt, what does performance time look like? 138,350 microseconds. Not bad, that’s a 4x speedup. Now I cheated a little bit, and tried various permutations of threads and ranges. It turns out the optimal time is when you have a number of threads equal to what your cpu can handle and your range is such that you’ll find your answer having to spawn threads only once. This was trivial to figure out via trial and error, but I suspect in future problems, we’re going to need a more robust approach to that solution.</p><p>Tune in next time, for some password generation (which we will not be able to parallelize).</p></div><div class="post-content"><h3>Series</h3><li><a href="/posts/advent-of-code-2015-rust-day-1/">Learning Rust with Advent of Code - Day 1</a><li><a href="/posts/advent-of-code-2015-rust-day-2/">Learning Rust with Advent of Code - Day 2</a><li><a href="/posts/advent-of-code-2015-rust-day-3/">Learning Rust with Advent of Code - Day 3</a><li><b>Learning Rust with Advent of Code - Day 4</b><li><a href="/posts/advent-of-code-2015-rust-day-5/">Learning Rust with Advent of Code - Day 5</a><li><a href="/posts/advent-of-code-2015-rust-day-6/">Learning Rust with Advent of Code - Day 6</a></div><hr><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/advent-of-code/'>Advent of Code</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/rust/" class="post-tag no-text-decoration" >rust</a> <a href="/tags/david/" class="post-tag no-text-decoration" >david</a> <a href="/tags/felipe/" class="post-tag no-text-decoration" >felipe</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Learning Rust with Advent of Code - Day 4 - Hall of Impossible Dreams&url=http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Learning Rust with Advent of Code - Day 4 - Hall of Impossible Dreams&u=http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Learning Rust with Advent of Code - Day 4 - Hall of Impossible Dreams&url=http://hallofdreams.org/posts/advent-of-code-2015-rust-day-4/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://giscus.app">giscus</a>.</p></div><script src="https://giscus.app/client.js" data-repo="thecog19/blog-comments-giscus" data-repo-id="R_kgDOH0cdtg" data-category="Announcements" data-category-id="DIC_kwDOH0cdts4CQ02w" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/thecog19">Dave and Felipe</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/david/">david</a> <a class="post-tag" href="/tags/felipe/">felipe</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/fiction/">fiction</a> <a class="post-tag" href="/tags/rust/">rust</a> <a class="post-tag" href="/tags/writing-prompts/">writing prompts</a> <a class="post-tag" href="/tags/poetry/">poetry</a> <a class="post-tag" href="/tags/essay/">essay</a> <a class="post-tag" href="/tags/mathematica/">mathematica</a> <a class="post-tag" href="/tags/hatetris/">hatetris</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="http://hallofdreams.org{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script> <script async src="https://www.googletagmanager.com/gtag/js?id=183607258"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', '183607258'); </script>
